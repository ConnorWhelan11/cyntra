#!/usr/bin/env bun
/**
 * Premed Shapes Generator
 * 
 * Reads SVG files from assets-src/ directory and generates a TypeScript module
 * with inline data URIs and metadata for the Premed Shapes library.
 * 
 * Usage:
 *   bun run scripts/generate-premed-shapes.ts
 * 
 * Input structure:
 *   src/components/ai-drawboard/premedShapes/assets-src/
 *   ├── clinical/
 *   │   ├── heart.svg
 *   │   └── heart.meta.json
 *   ├── lab/
 *   ├── anatomy/
 *   └── bio-chem/
 * 
 * Meta file format (optional):
 *   {
 *     "name": "Heart",
 *     "tags": ["cardiac", "cardiovascular"],
 *     "defaultWidth": 60,
 *     "defaultHeight": 60,
 *     "provenance": {
 *       "sourceName": "Lucide Icons",
 *       "sourceUrl": "https://lucide.dev",
 *       "licenseSpdx": "ISC",
 *       "licenseUrl": "https://github.com/lucide-icons/lucide/blob/main/LICENSE"
 *     }
 *   }
 */

import { readdir, readFile, writeFile, mkdir, stat } from "fs/promises";
import { join, basename, dirname } from "path";

// Types
interface ShapeProvenance {
  sourceName: string;
  sourceUrl: string;
  licenseSpdx: string;
  licenseUrl: string;
  author?: string;
}

interface ShapeMeta {
  name?: string;
  tags?: string[];
  defaultWidth?: number;
  defaultHeight?: number;
  provenance?: ShapeProvenance;
}

interface GeneratedShape {
  id: string;
  name: string;
  category: string;
  tags: string[];
  svgContent: string;
  defaultWidth: number;
  defaultHeight: number;
  provenance: ShapeProvenance;
}

// Constants
const PREMED_DIR = join(
  import.meta.dir,
  "../src/components/ai-drawboard/premedShapes"
);
const ASSETS_DIR = join(PREMED_DIR, "assets-src");
const OUTPUT_FILE = join(PREMED_DIR, "generated.ts");

const CATEGORIES = ["anatomy", "lab", "clinical", "bio-chem"] as const;

const DEFAULT_PROVENANCE: ShapeProvenance = {
  sourceName: "Unknown",
  sourceUrl: "",
  licenseSpdx: "UNLICENSED",
  licenseUrl: "",
};

// Helpers
function svgToDataUri(svg: string): string {
  return `data:image/svg+xml,${encodeURIComponent(svg.trim())}`;
}

function kebabToTitle(str: string): string {
  return str
    .split("-")
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(" ");
}

async function fileExists(path: string): Promise<boolean> {
  try {
    await stat(path);
    return true;
  } catch {
    return false;
  }
}

async function loadMeta(svgPath: string): Promise<ShapeMeta | null> {
  const metaPath = svgPath.replace(".svg", ".meta.json");
  if (await fileExists(metaPath)) {
    const content = await readFile(metaPath, "utf-8");
    return JSON.parse(content);
  }
  return null;
}

async function processCategory(category: string): Promise<GeneratedShape[]> {
  const categoryDir = join(ASSETS_DIR, category);
  
  if (!(await fileExists(categoryDir))) {
    console.log(`  [skip] ${category}/ not found`);
    return [];
  }

  const files = await readdir(categoryDir);
  const svgFiles = files.filter((f) => f.endsWith(".svg"));
  const shapes: GeneratedShape[] = [];

  for (const file of svgFiles) {
    const svgPath = join(categoryDir, file);
    const id = basename(file, ".svg");
    const svgContent = await readFile(svgPath, "utf-8");
    const meta = await loadMeta(svgPath);

    shapes.push({
      id,
      name: meta?.name ?? kebabToTitle(id),
      category,
      tags: meta?.tags ?? [],
      svgContent: svgContent.trim(),
      defaultWidth: meta?.defaultWidth ?? 60,
      defaultHeight: meta?.defaultHeight ?? 60,
      provenance: meta?.provenance ?? DEFAULT_PROVENANCE,
    });

    console.log(`  [add] ${category}/${id}`);
  }

  return shapes;
}

function generateTypeScript(shapes: GeneratedShape[]): string {
  const lines: string[] = [
    `/**`,
    ` * Premed Shapes — Generated Assets`,
    ` * Auto-generated by scripts/generate-premed-shapes.ts`,
    ` * Generated: ${new Date().toISOString()}`,
    ` * `,
    ` * DO NOT EDIT MANUALLY`,
    ` */`,
    ``,
    `import type { ShapeEntry, ShapeProvenance } from "./types";`,
    ``,
    `// Helper to create SVG data URI`,
    `const svgToDataUri = (svg: string): string =>`,
    `  \`data:image/svg+xml,\${encodeURIComponent(svg.trim())}\`;`,
    ``,
  ];

  // Group shapes by provenance to deduplicate
  const provenanceMap = new Map<string, { name: string; prov: ShapeProvenance }>();
  for (const shape of shapes) {
    const key = JSON.stringify(shape.provenance);
    if (!provenanceMap.has(key)) {
      const varName = `PROV_${provenanceMap.size + 1}`;
      provenanceMap.set(key, { name: varName, prov: shape.provenance });
    }
  }

  // Write provenance constants
  lines.push(`// Provenance constants`);
  for (const [key, { name, prov }] of provenanceMap) {
    lines.push(`const ${name}: ShapeProvenance = {`);
    lines.push(`  sourceName: ${JSON.stringify(prov.sourceName)},`);
    lines.push(`  sourceUrl: ${JSON.stringify(prov.sourceUrl)},`);
    lines.push(`  licenseSpdx: ${JSON.stringify(prov.licenseSpdx)},`);
    lines.push(`  licenseUrl: ${JSON.stringify(prov.licenseUrl)},`);
    if (prov.author) {
      lines.push(`  author: ${JSON.stringify(prov.author)},`);
    }
    lines.push(`};`);
    lines.push(``);
  }

  // Write SVG constants grouped by category
  const byCategory = new Map<string, GeneratedShape[]>();
  for (const shape of shapes) {
    const cat = byCategory.get(shape.category) ?? [];
    cat.push(shape);
    byCategory.set(shape.category, cat);
  }

  for (const [category, catShapes] of byCategory) {
    lines.push(`// ─────────────────────────────────────────────────────────────────────────────`);
    lines.push(`// ${kebabToTitle(category)} Shapes`);
    lines.push(`// ─────────────────────────────────────────────────────────────────────────────`);
    lines.push(``);

    for (const shape of catShapes) {
      const varName = `svg_${shape.id.replace(/-/g, "_")}`;
      lines.push(`const ${varName} = \`${shape.svgContent.replace(/`/g, "\\`")}\`;`);
      lines.push(``);
    }
  }

  // Write shapes array
  lines.push(`// ─────────────────────────────────────────────────────────────────────────────`);
  lines.push(`// Shape Registry Export`);
  lines.push(`// ─────────────────────────────────────────────────────────────────────────────`);
  lines.push(``);
  lines.push(`export const PREMED_SHAPES: ShapeEntry[] = [`);

  for (const shape of shapes) {
    const varName = `svg_${shape.id.replace(/-/g, "_")}`;
    const provKey = JSON.stringify(shape.provenance);
    const provName = provenanceMap.get(provKey)!.name;

    lines.push(`  {`);
    lines.push(`    id: ${JSON.stringify(shape.id)},`);
    lines.push(`    name: ${JSON.stringify(shape.name)},`);
    lines.push(`    category: ${JSON.stringify(shape.category)},`);
    lines.push(`    tags: ${JSON.stringify(shape.tags)},`);
    lines.push(`    svgDataUri: svgToDataUri(${varName}),`);
    lines.push(`    defaultWidth: ${shape.defaultWidth},`);
    lines.push(`    defaultHeight: ${shape.defaultHeight},`);
    lines.push(`    provenance: ${provName},`);
    lines.push(`  },`);
  }

  lines.push(`];`);
  lines.push(``);
  lines.push(`export const REGISTRY_VERSION = "0.2.0";`);
  lines.push(``);

  return lines.join("\n");
}

// Main
async function main() {
  console.log("Premed Shapes Generator");
  console.log("=======================");
  console.log(`Assets dir: ${ASSETS_DIR}`);
  console.log(`Output file: ${OUTPUT_FILE}`);
  console.log();

  // Check if assets dir exists
  if (!(await fileExists(ASSETS_DIR))) {
    console.log("Assets directory not found. Creating empty structure...");
    await mkdir(ASSETS_DIR, { recursive: true });
    for (const cat of CATEGORIES) {
      await mkdir(join(ASSETS_DIR, cat), { recursive: true });
    }
    console.log("Created assets-src/ structure. Add SVG files and re-run.");
    return;
  }

  // Process all categories
  console.log("Processing categories:");
  const allShapes: GeneratedShape[] = [];

  for (const category of CATEGORIES) {
    const shapes = await processCategory(category);
    allShapes.push(...shapes);
  }

  if (allShapes.length === 0) {
    console.log("\nNo shapes found. Add SVG files to assets-src/<category>/");
    return;
  }

  // Generate TypeScript
  console.log(`\nGenerating TypeScript (${allShapes.length} shapes)...`);
  const ts = generateTypeScript(allShapes);
  await writeFile(OUTPUT_FILE, ts, "utf-8");

  console.log(`\n✓ Generated ${OUTPUT_FILE}`);
  console.log(`  ${allShapes.length} shapes in ${byCategory(allShapes).size} categories`);
}

function byCategory(shapes: GeneratedShape[]): Map<string, GeneratedShape[]> {
  const map = new Map<string, GeneratedShape[]>();
  for (const shape of shapes) {
    const cat = map.get(shape.category) ?? [];
    cat.push(shape);
    map.set(shape.category, cat);
  }
  return map;
}

main().catch((err) => {
  console.error("Error:", err);
  process.exit(1);
});

